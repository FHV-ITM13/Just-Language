/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(EG1)package just.grammar;import java.io.FileInputStream;import java.io.File;import just.grammar.semantics.*;import just.grammar.semantics.Symbol.Kind;import just.grammar.codegeneration.*;import just.grammar.codegeneration.code.*;import just.grammar.codegeneration.classfile.*;import just.grammar.codegeneration.classfile.constants.*;public class EG1{  static SymbolTable symbolTable;  static NameList nameList;  static Classfile classfile;  static CodeGen codeGen;  public static void main(String args []) throws ParseException  {    try    {      EG1 parser = new EG1(new FileInputStream(new File("res/DTest.jus")));      symbolTable = SymbolTable.SymbolTable;      nameList = NameList.NameList;      codeGen = CodeGen.CodeGen;      classfile = new Classfile();      System.out.println("Reading from file");      parser.readFile();      System.out.println("Code is valid!");      System.out.println("####################################");      System.out.println("Printing Scopes with variables:");      symbolTable.printScopes();      System.out.println("####################################");      System.out.println("Writing classfile...");      boolean result = classfile.generateClassfile(String.format("res/%s.ojus", classfile.getClassConstant().getName().getBytes()));      System.out.println(result ? "Classfile was successfully created!" : "Classfile could not be created! See log");    }    catch (Exception e)    {      System.out.println("Exception:");      System.out.println(e.getMessage());      EG1.ReInit(System.in);    }    catch (Error e)    {      System.out.println("Error:");      System.out.println(e.getMessage());    }  }}PARSER_END(EG1)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < ASSIGN : "=" >| < AND : "&&" >| < OR : "||" >| < EQ : "==" >| < NOTEQ : "!=" >| < SMALLER : "<" >| < SMALLEREQ : "<=" >| < GREATER : ">" >| < GREATEREQ : ">=" >| < NOT : "!" >}TOKEN : /* NUMBER */{  < NUMBER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}TOKEN : /* TYPES */{  < INT : "int" >| < VOID : "void" >| < BOOLEAN : "boolean" >| < ARRAY : (< RECTBRACKETOPEN > < RECTBRACKETCLOSE >) >}TOKEN : /* KEYWORDS */{  < PROGRAM : "program" >| < IF : "if" >| < ELSE : "else" >| < WHILE : "while" >| < RETURN : "return" >| < BYREF : "byref" >| < DO : "do" >| < SYNC : "synchronized" >| < IMPORT : "import" >| < COROUTINE : "coroutine" >| < CALL : "call" >| < NEW : "new" >| < FUNCTION : "function" >}TOKEN : /* SYMBOLS */{  < END : ";" >| < SEPERATOR : "," >| < TRUE : "true" >| < FALSE : "false" >}TOKEN : /* brackets */{  < CURLYBRACKETOPEN : "{" >| < CURLYBRACKETCLOSE : "}" >| < ROUNDBRACKETOPEN : "(" >| < ROUNDBRACKETCLOSE : ")" >| < RECTBRACKETOPEN : "[" >| < RECTBRACKETCLOSE : "]" >}TOKEN : /* IDENT */{  < IDENT :    (      < LOWERLETTER >    | < UPPERLETTER >    )    (      < LOWERLETTER >    | < UPPERLETTER >    | < NUMBER >    )* >| < #LOWERLETTER : [ "a"-"z" ] >| < #UPPERLETTER : [ "A"-"Z" ] >}void readFile() :{}{  CompilationUnit()}void CompilationUnit() :{  Symbol symbol;  Constant classConstant;  Token identToken;}{  (< IMPORT > < IDENT > < END >)* < PROGRAM > identToken = < IDENT >  {    symbolTable.enterScope(identToken.image);    int spix = nameList.insert(identToken.image);    symbol = new Symbol(spix, Kind.programKind);    symbolTable.insert(symbol);    classConstant = classfile.addClassConstant(symbol);  }  < CURLYBRACKETOPEN > Definition() < CURLYBRACKETCLOSE >  {    symbolTable.leaveScope();  }}void Definition() :{}{  (    VarDef(Kind.fieldKind)  | FuncDef()  )*}void VarDef(Kind kind) :{  Type type;  Token token;  Symbol symbol;}{  type = Type() (< ARRAY >)? token = < IDENT >  {    int spix = nameList.insert(token.image);    symbol = new Symbol(spix, kind, type);    symbolTable.insert(symbol);    classfile.addVarConstant(symbol);  }  (    < ASSIGN > Expr(null)    {      symbol.init = true;    }  )? < END >}Type Type() :{}{  (    < VOID >    {      return Type.voidType;    }  | < INT >    {      return Type.intType;    }  | < BOOLEAN >    {      return Type.boolType;    }  )}void FuncDef() :{  Type type;  Token identToken;  Symbol symbol;}{  < FUNCTION > (< COROUTINE >)? type = Type() identToken = < IDENT >  {    int spix = nameList.insert(identToken.image);    symbol = symbolTable.lookup(identToken.image);    if (symbol == null)    {      symbol = new MethodSymbol(spix, type);      symbolTable.insert(symbol);    }    else    {      symbol.type = type;    }    symbolTable.enterScope(identToken.image);  }  < ROUNDBRACKETOPEN > FormParamList  (    (MethodSymbol) symbol  )  < ROUNDBRACKETCLOSE >  {    MethodRefConstant method = (MethodRefConstant) classfile.addMethodConstant((MethodSymbol) symbol, symbolTable.getCurrentScope());    codeGen.setCurrCode(method.getMethodCode());  }  Block()  {    symbolTable.leaveScope();  }}void FormParamList(MethodSymbol method) :{}{  (    FormParam(method)    (      < SEPERATOR > FormParam(method)    )*  )?}void FormParam(MethodSymbol method) :{  Type type;  Token token;  Symbol symbol;}{  (< BYREF >)? type = Type() token = < IDENT >  {    int spix = nameList.insert(token.image);    symbol = new Symbol(spix, Kind.parKind, type);    symbolTable.insert(symbol);    method.addParam(symbol);  }}void Block() :{}{  < CURLYBRACKETOPEN >  (    Stat()  )*  < CURLYBRACKETCLOSE >}void Stat() :{}{  VarDef(Kind.varKind)| AssignStat()| CallStat()| IfStat()| WhileStat()| ReturnStat()| < END >}void AssignStat() :{  Token token;  Symbol symbol;}{  token = < IDENT >  {    symbol = symbolTable.lookup(token.image);  }  < ASSIGN > Expr(null) < END >  {    if (symbol != null)    {      codeGen.store(codeGen.newDescriptor(symbol));    }    else    {      //you cannot use local variables before their declaration
      //so it must be a field - methods have a "call" before their name 
      symbol = new Symbol(nameList.insert(token.image), Kind.fieldKind, Type.undefType);      codeGen.load(codeGen.newDescriptor(symbol));    }  }}void CallStat() :{}{  Call() < END >}void Call() :{  Token token;}{  < CALL > token = < IDENT > < ROUNDBRACKETOPEN >  (    ActParList()  )?  < ROUNDBRACKETCLOSE >  {    Symbol symbol = symbolTable.lookup(token.image);    if (symbol == null)    {      int spix = nameList.insert(token.image);      symbol = new MethodSymbol(spix);      symbolTable.insert(symbol);    }    codeGen.call(codeGen.newDescriptor(symbol));  }}void ActParList() :{}{  Expr(null)  (    < SEPERATOR > Expr(null)  )*}void IfStat() :{  LabelDescriptor desc = new LabelDescriptor();  Label endifLabel = null;}{  < IF > < ROUNDBRACKETOPEN > Expr(desc) < ROUNDBRACKETCLOSE >  {    symbolTable.enterScope("if");  }  Block()  {    symbolTable.leaveScope();  }  (    < ELSE >    {      symbolTable.enterScope("else");      endifLabel = codeGen.createLabel();      codeGen.jump(endifLabel);      codeGen.markByLabel(desc.getLabel());    }    Block()    {      symbolTable.leaveScope();      codeGen.markByLabel(endifLabel);    }  | //no else
    {      codeGen.markByLabel(desc.getLabel());     }  )}void WhileStat() :{
  LabelDescriptor desc = new LabelDescriptor();
  Label beforeWhileLabel = null;
}{
  {	beforeWhileLabel = codeGen.createLabel();
	codeGen.markByLabel(beforeWhileLabel); 
  }  < WHILE > < ROUNDBRACKETOPEN > Expr(desc) < ROUNDBRACKETCLOSE >  {    symbolTable.enterScope("while");  }  Block()  {    symbolTable.leaveScope();
    codeGen.jump(beforeWhileLabel);
	codeGen.markByLabel(desc.getLabel());  }}void ReturnStat() :{}{  < RETURN >  (    Expr(null)  )?  < END >  {    codeGen.emit(OpCode.IRETURN);  }}void Expr(LabelDescriptor desc) :{}{  OrExpr(desc)}void OrExpr(LabelDescriptor desc) :{}{  AndExpr(desc)  (    < OR > AndExpr(desc)    {
      //FIXME      //codeGen.emit(OpCode.IOR);    }  )*}void AndExpr(LabelDescriptor desc) :{}{  RelExpr(desc)  (    < AND > RelExpr(desc)    {
      //FIXME      //codeGen.emit(OpCode.IAND);    }  )*}void RelExpr(LabelDescriptor desc) :{  OpCode opCode;}{  SimpleExpr()  (    opCode = ComparisonOperators()    SimpleExpr()
    {
        if(desc != null)
        {
			codeGen.falseJump(opCode, desc);
        }
    }  )?}void SimpleExpr() :{  OpCode opCode;}{  (    PlusMinus()  )?  Term()  (    opCode = PlusMinus() Term()    {      codeGen.emit(opCode);    }  )*}OpCode PlusMinus() :{}{  < PLUS >  {    return OpCode.IADD;  }| < MINUS >  {    return OpCode.ISUB;  }}void Term() :{  OpCode opCode;}{  NotFact()  (    opCode = MuliplyDivide() NotFact()    {      codeGen.emit(opCode);    }  )*}void NotFact() :{}{  (< NOT >)? Fact()}void Fact() :{  Constant constant;  Symbol symbol;}{  (    < NUMBER >    {      symbol = new Symbol(nameList.insert(token.image), Kind.constKind, Type.intType);      symbol.val = Integer.parseInt(token.image);      constant = classfile.addValueConstant(symbol);      codeGen.load(codeGen.newDescriptor(symbol));    }  | < TRUE >    {      symbol = new Symbol(nameList.insert(token.image), Kind.constKind, Type.boolType);      symbol.val = 1;      constant = classfile.addValueConstant(symbol);      codeGen.load(codeGen.newDescriptor(symbol));    }  | < FALSE >    {      symbol = new Symbol(nameList.insert(token.image), Kind.constKind, Type.boolType);      symbol.val = 0;      constant = classfile.addValueConstant(symbol);      codeGen.load(codeGen.newDescriptor(symbol));    }  | < IDENT >    {      symbol = symbolTable.lookup(token.image);      if (symbol != null)      {        codeGen.load(codeGen.newDescriptor(symbol));      }      else      {        //you cannot use local variables before their declaration
        //so it must be a field - methods have a "call" before their name 
        symbol = new Symbol(nameList.insert(token.image), Kind.fieldKind, Type.undefType);        codeGen.load(codeGen.newDescriptor(symbol));      }    }  | Call()  |    (      < ROUNDBRACKETOPEN > Expr(null) < ROUNDBRACKETCLOSE >    )  | < NEW > Type() < RECTBRACKETOPEN > < NUMBER > < RECTBRACKETCLOSE >  )}OpCode MuliplyDivide() :{}{  < MULTIPLY >  {    return OpCode.IMUL;  }| < DIVIDE >  {    return OpCode.IDIV;  }}OpCode ComparisonOperators() :{}{  (    < EQ >    {      return OpCode.IF_ICMPEQ;    }  | < NOTEQ >    {      return OpCode.IF_ICMPNE;    }  | < SMALLER >    {      return OpCode.IF_ICMPLE;    }  | < SMALLEREQ >    {      return OpCode.IF_ICMPLT;    }  | < GREATER >    {      return OpCode.IF_ICMPGE;    }  | < GREATEREQ >    {      return OpCode.IF_ICMPGT;    }  )}