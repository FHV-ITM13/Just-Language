/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(EG1)package just.grammar;import java.io.FileInputStream;import java.io.File;import just.grammar.semantics.*;import just.grammar.semantics.Symbol.Kind;import just.grammar.semantics.*;import just.grammar.codegeneration.classfile.constants.*;import just.grammar.codegeneration.classfile.*;import just.grammar.codegeneration.*;public class EG1{  static SymbolTable symbolTable;  static NameList nameList;  static Classfile classfile;  static CodeGen codeGen;  public static void main(String args []) throws ParseException  {    try    {      EG1 parser = new EG1(new FileInputStream(new File("res/ATest.jus")));      symbolTable = SymbolTable.SymbolTable;      nameList = NameList.NameList;      codeGen = CodeGen.CodeGen;      classfile = new Classfile();      System.out.println("Reading from file");      parser.readFile();      System.out.println("Code is valid!");      System.out.println("####################################");      System.out.println("Printing Scopes with variables:");      symbolTable.printScopes();      System.out.println("####################################");      System.out.println("Writing class file...");      classfile.write(String.format("res/%s.ojus", classfile.getClassConstant().getName().getBytes()));      System.out.println("Class file was successfully created!");    }    catch (Exception e)    {      System.out.println("Exception:");      System.out.println(e.getMessage());      EG1.ReInit(System.in);    }    catch (Error e)    {      System.out.println("Error:");      System.out.println(e.getMessage());    }  }}PARSER_END(EG1)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < ASSIGN : "=" >| < AND : "&&" >| < OR : "||" >| < EQ : "==" >| < NOTEQ : "!=" >| < SMALLER : "<" >| < SMALLEREQ : "<=" >| < GREATER : ">" >| < GREATEREQ : ">=" >| < NOT : "!" >}TOKEN : /* NUMBER */{  < NUMBER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}TOKEN : /* TYPES */{  < INT : "int" >| < VOID : "void" >| < BOOLEAN : "boolean" >| < ARRAY : (< RECTBRACKETOPEN > < RECTBRACKETCLOSE >) >}TOKEN : /* KEYWORDS */{  < PROGRAM : "program" >| < IF : "if" >| < ELSE : "else" >| < WHILE : "while" >| < RETURN : "return" >| < BYREF : "byref" >| < DO : "do" >| < SYNC : "synchronized" >| < IMPORT : "import" >| < COROUTINE : "coroutine" >| < CALL : "call" >| < NEW : "new" >| < FUNCTION : "function" >}TOKEN : /* SYMBOLS */{  < END : ";" >| < SEPERATOR : "," >| < TRUE : "true" >| < FALSE : "false" >}TOKEN : /* brackets */{  < CURLYBRACKETOPEN : "{" >| < CURLYBRACKETCLOSE : "}" >| < ROUNDBRACKETOPEN : "(" >| < ROUNDBRACKETCLOSE : ")" >| < RECTBRACKETOPEN : "[" >| < RECTBRACKETCLOSE : "]" >}TOKEN : /* IDENT */{  < IDENT :    (      < LOWERLETTER >    | < UPPERLETTER >    )    (      < LOWERLETTER >    | < UPPERLETTER >    | < NUMBER >    )* >| < #LOWERLETTER : [ "a"-"z" ] >| < #UPPERLETTER : [ "A"-"Z" ] >}void readFile() :{}{  CompilationUnit()}void CompilationUnit() :{  Symbol symbol;  Constant classConstant;  Token identToken;}{  (< IMPORT > < IDENT > < END >)* < PROGRAM > identToken = < IDENT >  {    symbolTable.enterScope(identToken.image);    int spix = nameList.insert(identToken.image);    symbol = new Symbol(spix, Kind.programKind);    symbolTable.insert(symbol);    classConstant = classfile.addClassConstant(symbol);  }  < CURLYBRACKETOPEN > Definition() < CURLYBRACKETCLOSE >  {    symbolTable.leaveScope();  }}void Definition() :{}{  (    VarDef(Kind.fieldKind)  | FuncDef()  )*}void VarDef(Kind kind) :{  Type type;  Token token;  Symbol symbol;}{  type = Type() (< ARRAY >)? token = < IDENT >  {    int spix = nameList.insert(token.image);    symbol = new Symbol(spix, kind, type);    symbolTable.insert(symbol);    classfile.addVarConstant(symbol);  }  (    Init(symbol)  )?  < END >}void Init(Symbol varSy) :{  varSy.init = true;}{  //TODO set symbol.val 
  < ASSIGN > Expr()| CallStat()}Type Type() :{}{  (    < VOID >    {      return Type.voidType;    }  | < INT >    {      return Type.intType;    }  | < BOOLEAN >    {      return Type.boolType;    }  )}void FuncDef() :{  Type type;  Token identToken;  Symbol symbol;}{  < FUNCTION > (< COROUTINE >)? type = Type() identToken = < IDENT >  {    int spix = nameList.insert(identToken.image);    symbol = symbolTable.lookup(identToken.image);

    if(symbol == null)    {
     symbol = new MethodSymbol(spix, type);
     symbolTable.insert(symbol);
    } else    {
      symbol.type = type;
    }    symbolTable.enterScope(identToken.image);  }  < ROUNDBRACKETOPEN > FormParamList((MethodSymbol)symbol) < ROUNDBRACKETCLOSE >  {    MethodRefConstant method = (MethodRefConstant) classfile.addMethodConstant((MethodSymbol)symbol, symbolTable.getCurrentScope());    codeGen.setCurrCode(method.getMethodCode());  }  Block()  {    symbolTable.leaveScope();  }}void FormParamList(MethodSymbol method) :{}{  (    FormParam(method)    (      < SEPERATOR > FormParam(method)    )*  )?}void FormParam(MethodSymbol method) :{  Type type;  Token token;  Symbol symbol;}{  (< BYREF >)? type = Type() token = < IDENT >  {    int spix = nameList.insert(token.image);    symbol = new Symbol(spix, Kind.parKind, type);    symbolTable.insert(symbol);    method.addParam(symbol);  }}void Block() :{}{  < CURLYBRACKETOPEN >  (    Stat()  )*  < CURLYBRACKETCLOSE >}void Stat() :{}{  VarDef(Kind.varKind)| AssignStat()| CallStat()| IfStat()| WhileStat()| ReturnStat()| < END >}void AssignStat() :{  Token token;  Symbol symbol;}{  token = < IDENT >  {    symbol = symbolTable.lookup(token.image);  }  < ASSIGN > Expr()  {    if (symbol != null)    {      codeGen.store(codeGen.newDescriptor(symbol));    }    else    { //TODO FIXUP
    }  }}void CallStat() :{}{  Call() < END >}void Call() :{
  Token token;
}{  < CALL > token = < IDENT > < ROUNDBRACKETOPEN >  (    ActParList()  )?  < ROUNDBRACKETCLOSE >
  {
    Symbol symbol = symbolTable.lookup(token.image);
    if(symbol == null)    {
//	    int spix = nameList.insert(identToken.image);//	    symbol = new MethodSymbol(spix, Kind.funcKind, type);//	    symbolTable.insert(symbol);
    }	codeGen.emit2(OpCode.INVOKESTATIC, codeGen.newDescriptor(symbol));
  }}void ActParList() :{}{  Expr()  (    < SEPERATOR > Expr()  )*}void IfStat() :{}{  < IF > < ROUNDBRACKETOPEN > Expr() < ROUNDBRACKETCLOSE >  {    symbolTable.enterScope("if");  }  Block()  {    symbolTable.leaveScope();  }  (    < ELSE >    {      symbolTable.enterScope("else");    }    Block()    {      symbolTable.leaveScope();    }  )?}void WhileStat() :{}{  < WHILE > < ROUNDBRACKETOPEN > Expr() < ROUNDBRACKETCLOSE >  {    symbolTable.enterScope("while");  }  Block()  {    symbolTable.leaveScope();  }}void ReturnStat() :{}{  < RETURN >  (    Expr()  )?  < END >}void Expr() :{}{  OrExpr()}void OrExpr() :{}{  AndExpr()  (    < OR > AndExpr()  )*}void AndExpr() :{}{  RelExpr()  (    < AND > RelExpr()  )*}void RelExpr() :{}{  SimpleExpr()  (    (      ComparisonOperators()    )    SimpleExpr()  )?}void SimpleExpr() :{}{  (    PlusMinus()  )?  Term()  (    PlusMinus() Term()  )*}void PlusMinus() :{}{  < PLUS >  {    codeGen.emit(OpCode.IADD);  }| < MINUS >  {    codeGen.emit(OpCode.ISUB);  }}void Term() :{}{  NotFact()  (    MuliplyDivide() NotFact()  )*}void NotFact() :{}{  (< NOT >)? Fact()}void Fact() :{}{  (    < NUMBER >    {      codeGen.emit2(OpCode.LDC_W, token.image);    }  | < TRUE >    {      codeGen.emit2(OpCode.LDC_W, 1);
    }  | < FALSE >    {      codeGen.emit2(OpCode.LDC_W, 0);    }  | < IDENT >    {      Symbol symbol = symbolTable.lookup(token.image);      if (symbol != null)      {        codeGen.load(codeGen.newDescriptor(symbol));      }      else      { //TODO FIXUP      }    }  | CallStat()  |    (      < ROUNDBRACKETOPEN > Expr() < ROUNDBRACKETCLOSE >    )  | < NEW > Type() < RECTBRACKETOPEN > < NUMBER > < RECTBRACKETCLOSE >  )}void MuliplyDivide() :{}{  < MULTIPLY >  {    codeGen.emit(OpCode.IMUL);  }| < DIVIDE >  {    codeGen.emit(OpCode.IDIV);  }}void ComparisonOperators() :{}{  (    < EQ >    {      codeGen.emit(OpCode.IMUL);    }  | < NOTEQ >    {      codeGen.emit(OpCode.IMUL);    }  | < SMALLER >    {      codeGen.emit(OpCode.IMUL);    }  | < SMALLEREQ >    {      codeGen.emit(OpCode.IMUL);    }  | < GREATER >    {      codeGen.emit(OpCode.IMUL);    }  | < GREATEREQ >    {      codeGen.emit(OpCode.IMUL);    }  )}