/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  JDK_VERSION = "1.5";
  static = true;
}

PARSER_BEGIN(EG1)
package just.grammar;
import java.io.FileInputStream;
import java.io.File;
import just.grammar.semantics.*;
import just.grammar.semantics.Symbol.Kind;
import just.grammar.semantics.*;
import just.grammar.codegeneration.classfile.constants.*;
import just.grammar.codegeneration.classfile.*;

public class EG1
{
  static SymbolTable symbolTable;
  static NameList nameList;
  static Classfile classfile;
  
  public static void main(String args []) throws ParseException
  {
    try
    {
      EG1 parser = new EG1(new FileInputStream(new File("res/BTest.jus")));
      
	  symbolTable = SymbolTable.SymbolTable;
      nameList = NameList.NameList;
      classfile = new Classfile();
      
      System.out.println("Reading from file");
      parser.readFile();
      System.out.println("Code is valid!");
      
      System.out.println("####################################");
 
      System.out.println("Printing Scopes with variables:");
      symbolTable.printScopes();

      System.out.println("####################################");
      System.out.println("Writing class file...");
      classfile.write(String.format("res/%s.ojus", classfile.getClassConstant().getName().getBytes()));
      System.out.println("Class file was successfully created!");
      
    }
      catch (Exception e)
      {
        System.out.println("Exception:");
        System.out.println(e.getMessage());
        EG1.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Error:");
        System.out.println(e.getMessage());
      }
    }
  }

PARSER_END(EG1)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : /* OPERATORS */
{
  	< PLUS : "+" >
| 	< MINUS : "-" >
| 	< MULTIPLY : "*" >
|	< DIVIDE : "/" >
|	< ASSIGN : "=" >
| 	< AND : "&&" >
| 	< OR : "||" >
| 	< EQ : "==" >
| 	< NOTEQ : "!=" >
| 	< SMALLER : "<" >
| 	< SMALLEREQ : "<=" >
| 	< GREATER : ">" >
| 	< GREATEREQ : ">=" >
| 	< NOT : "!" >
}

TOKEN : /* NUMBER */
{
  < NUMBER : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
}

TOKEN: /* TYPES */
{
	< INT : "int" >
|	< VOID : "void" >
|	< BOOLEAN : "boolean" >
|	< ARRAY : ( < RECTBRACKETOPEN > < RECTBRACKETCLOSE > ) >
}

TOKEN: /* KEYWORDS */
{
	< PROGRAM : "program" >
| 	< IF : "if" >
| 	< ELSE : "else" >
| 	< WHILE : "while" >
| 	< RETURN : "return" >
| 	< BYREF : "byref" >
| 	< DO : "do" >
| 	< SYNC : "synchronized" >
| 	< IMPORT : "import" >
| 	< COROUTINE : "coroutine" >
| 	< CALL : "call" >
|   < NEW : "new" >
| 	< FUNCTION : "function" >
}

TOKEN: /* SYMBOLS */
{
	< END : ";" >
|	< SEPERATOR : "," >
|	< TRUE : "true" >
|	< FALSE : "false" >
}

TOKEN: /* brackets */
{
	< CURLYBRACKETOPEN : "{" >
| 	< CURLYBRACKETCLOSE :"}" >
| 	< ROUNDBRACKETOPEN : "(" >
| 	< ROUNDBRACKETCLOSE : ")" >
| 	< RECTBRACKETOPEN : "[" >
| 	< RECTBRACKETCLOSE : "]" >
}

TOKEN : /* IDENT */
{
  < IDENT : (< LOWERLETTER > | < UPPERLETTER >) (< LOWERLETTER > | < UPPERLETTER > | < NUMBER >)* >
| < #LOWERLETTER : [ "a"-"z" ] >
| < #UPPERLETTER : [ "A"-"Z" ] >
}

void readFile() :
{}
{
  	CompilationUnit()
}

void CompilationUnit() :
{
  Symbol symbol;
  Constant classConstant;
  Token identToken;
}
{
  	(< IMPORT ><IDENT ><END >)*
  	< PROGRAM >
  	identToken = <IDENT>  	{
	  symbolTable.enterScope(identToken.image);
  	  
  	  int spix = nameList.insert(identToken.image);
	  symbol = new Symbol(spix, Kind.programKind);
	  symbolTable.insert(symbol);
	  classConstant = classfile.addClassConstant(symbol);
  	}
  	<CURLYBRACKETOPEN>
  		Definition()
  	<CURLYBRACKETCLOSE>
  	{		symbolTable.leaveScope();
  	}
}

void Definition() :
{}
{
  (
      VarDef(Kind.fieldKind)
    | FuncDef()
  )*
}

void VarDef(Kind kind) :
{
  	Type type;
	Token token;
	Symbol symbol;
}
{
	type = Type() (< ARRAY >)? token = < IDENT >
	{
	  int spix = nameList.insert(token.image);
	  symbol = new Symbol(spix, kind, type);
	  symbolTable.insert(symbol);
	  classfile.addVarConstant(symbol);
	}
	( Init(symbol) )? < END >
}

void Init(Symbol varSy) :
{
	varSy.init = true;
}
{
  //TODO set symbol.val 
  	< ASSIGN > Expr()
}

Type Type():
{
}
{
  (
	< VOID >
	{
		return Type.voidType;
	}
	|  < INT >
	{
		return Type.intType;
	}
	| < BOOLEAN >
	{
		return Type.boolType;
	}
  )
}

void FuncDef():
{}
{
	FuncHead() Block()
}

void FuncHead():
{
  	Type type;
	Token identToken;
	MethodSymbol symbol;
}
{
	< FUNCTION > (< COROUTINE >)? type = Type()
	identToken = < IDENT >
	{
	  int spix = nameList.insert(identToken.image);
	  symbol = new MethodSymbol(spix, Kind.funcKind, type);
	  symbolTable.insert(symbol);
	  
	  symbolTable.enterScope(identToken.image);
	}
	< ROUNDBRACKETOPEN > ( FormParList(symbol) )? < ROUNDBRACKETCLOSE >
	{
	  classfile.addMethodConstant(symbol);	}
}

void FormParList(MethodSymbol method):
{
  	Type type;
	Token token;
	Symbol symbol;
}
{
	( < BYREF > )? type = Type()
	token = < IDENT >
	{
	  int spix = nameList.insert(token.image);
	  symbol = new Symbol(spix, Kind.parKind, type);
	  symbolTable.insert(symbol);
	  method.addParam(symbol);
	}
	(
	    < SEPERATOR > ( < BYREF > )? type = Type()
	    token = < IDENT >
		{
		  spix = nameList.insert(token.image);
		  symbol = new Symbol(spix, Kind.parKind, type);
		  symbolTable.insert(symbol);
		  method.addParam(symbol);
		}
	)*
}

void Block() :
{}
{
	< CURLYBRACKETOPEN >
	(
	  	VarDef(Kind.varKind) | Stat()
	)*
	<CURLYBRACKETCLOSE >
	{
		symbolTable.leaveScope();
	}
}

void Stat() :
{}
{
  	  AssignStat()
	| CallStat()
	| IfStat()
	| WhileStat()
	| ReturnStat()
	| Block()
	| < END >
}

void AssignStat() :
{
	Token token;
	Symbol symbol;
}
{
  	token = < IDENT >
  	{
  	  symbol = symbolTable.lookup(token.image);  	}

  	<ASSIGN > Expr() <END >
}

void CallStat() :
{}
{
  	< CALL > Call() < END >
}

void Call():
{}
{
	< IDENT > <ROUNDBRACKETOPEN > ( ActParList() )? <ROUNDBRACKETCLOSE > 
}

void ActParList():
{}
{
	Expr() ( < SEPERATOR > Expr() )*
}

void IfStat() :
{}
{
	< IF > < ROUNDBRACKETOPEN >	 Expr() < ROUNDBRACKETCLOSE >
	< CURLYBRACKETOPEN >
	{
	  symbolTable.enterScope("if");
	}
	 Stat()
	< CURLYBRACKETCLOSE >
	{
	  symbolTable.leaveScope();
	}
	(
	  < ELSE >
	  < CURLYBRACKETOPEN >
	  {
	  	symbolTable.enterScope("else");
	  }
		
	  Stat()

	   < CURLYBRACKETCLOSE >
		{
		  symbolTable.leaveScope();
		}
	 )?
}

void WhileStat() :
{}
{
	< WHILE > <ROUNDBRACKETOPEN > Expr() <ROUNDBRACKETCLOSE >
	< CURLYBRACKETOPEN >
	{
	  symbolTable.enterScope("while");
	}
		Stat()
		
	< CURLYBRACKETCLOSE >
	{
	  symbolTable.leaveScope();
	}
}

void ReturnStat() :
{}
{
  < RETURN > ( Expr() )? < END >
}

void Expr():
{}
{
	OrExpr()
}

void OrExpr():
{}
{
	AndExpr()
	(
		< OR > AndExpr()
	)*
}

void AndExpr():
{}
{
	RelExpr()
	(
		< AND > RelExpr()
	)*
}

void RelExpr():
{}
{
	SimpleExpr()
	(
	  	(
	  		ComparisonOperators()
	  	)
	  	SimpleExpr()
	)? 
}

void SimpleExpr():
{}
{
	( PlusMinus() )? Term()
	(
		PlusMinus() Term()
	)*
}

void PlusMinus():
{}
{
  	< PLUS > | < MINUS >
}

void Term():
{}
{
	NotFact()
	(
	  	MuliplyDivide() NotFact()
	)*
}

void NotFact():
{}
{
  	( < NOT > )? Fact()
}

void Fact():
{}
{
  	(
		< NUMBER >
	  | < FALSE >
	  | < TRUE >
	  | < IDENT >
	  | CallStat()
	  | (< ROUNDBRACKETOPEN > Expr()  < ROUNDBRACKETCLOSE >)
	  | < NEW > Type() < RECTBRACKETOPEN >  <NUMBER > < RECTBRACKETCLOSE >
	)
}

void MuliplyDivide():
{}
{
  	< MULTIPLY > | < DIVIDE >
}

void ComparisonOperators():
{}
{
	(
  		< EQ >
	  | < NOTEQ >
	  | < SMALLER >
	  | < SMALLEREQ >
	  | < GREATER >
	  | < GREATEREQ >
	)
}