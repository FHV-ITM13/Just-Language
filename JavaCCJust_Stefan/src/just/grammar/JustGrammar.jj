/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(EG1)package just.grammar;import java.io.FileInputStream;import java.io.File;import just.grammar.semantics.*;import just.grammar.semantics.Symbol.Kind;import just.grammar.semantics.*;import just.grammar.codegeneration.classfile.constants.*;import just.grammar.codegeneration.classfile.*;
import just.grammar.codegeneration.*;public class EG1{  static SymbolTable symbolTable;  static NameList nameList;  static Classfile classfile;
  static CodeGen codeGen;  public static void main(String args []) throws ParseException  {    try    {      EG1 parser = new EG1(new FileInputStream(new File("res/ATest.jus")));      symbolTable = SymbolTable.SymbolTable;      nameList = NameList.NameList;
      codeGen = CodeGen.CodeGen;      classfile = new Classfile();      System.out.println("Reading from file");      parser.readFile();      System.out.println("Code is valid!");      System.out.println("####################################");      System.out.println("Printing Scopes with variables:");      symbolTable.printScopes();      System.out.println("####################################");      System.out.println("Writing class file...");      classfile.write(String.format("res/%s.ojus", classfile.getClassConstant().getName().getBytes()));      System.out.println("Class file was successfully created!");    }    catch (Exception e)    {      System.out.println("Exception:");      System.out.println(e.getMessage());      EG1.ReInit(System.in);    }    catch (Error e)    {      System.out.println("Error:");      System.out.println(e.getMessage());    }  }}PARSER_END(EG1)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < ASSIGN : "=" >| < AND : "&&" >| < OR : "||" >| < EQ : "==" >| < NOTEQ : "!=" >| < SMALLER : "<" >| < SMALLEREQ : "<=" >| < GREATER : ">" >| < GREATEREQ : ">=" >| < NOT : "!" >}TOKEN : /* NUMBER */{  < NUMBER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}TOKEN : /* TYPES */{  < INT : "int" >| < VOID : "void" >| < BOOLEAN : "boolean" >| < ARRAY : (< RECTBRACKETOPEN > < RECTBRACKETCLOSE >) >}TOKEN : /* KEYWORDS */{  < PROGRAM : "program" >| < IF : "if" >| < ELSE : "else" >| < WHILE : "while" >| < RETURN : "return" >| < BYREF : "byref" >| < DO : "do" >| < SYNC : "synchronized" >| < IMPORT : "import" >| < COROUTINE : "coroutine" >| < CALL : "call" >| < NEW : "new" >| < FUNCTION : "function" >}TOKEN : /* SYMBOLS */{  < END : ";" >| < SEPERATOR : "," >| < TRUE : "true" >| < FALSE : "false" >}TOKEN : /* brackets */{  < CURLYBRACKETOPEN : "{" >| < CURLYBRACKETCLOSE : "}" >| < ROUNDBRACKETOPEN : "(" >| < ROUNDBRACKETCLOSE : ")" >| < RECTBRACKETOPEN : "[" >| < RECTBRACKETCLOSE : "]" >}TOKEN : /* IDENT */{  < IDENT :    (      < LOWERLETTER >    | < UPPERLETTER >    )    (      < LOWERLETTER >    | < UPPERLETTER >    | < NUMBER >    )* >| < #LOWERLETTER : [ "a"-"z" ] >| < #UPPERLETTER : [ "A"-"Z" ] >}void readFile() :{}{  CompilationUnit()}void CompilationUnit() :{  Symbol symbol;  Constant classConstant;  Token identToken;}{  (< IMPORT > < IDENT > < END >)* < PROGRAM > identToken = < IDENT >  {    symbolTable.enterScope(identToken.image);    int spix = nameList.insert(identToken.image);    symbol = new Symbol(spix, Kind.programKind);    symbolTable.insert(symbol);    classConstant = classfile.addClassConstant(symbol);  }  < CURLYBRACKETOPEN > Definition() < CURLYBRACKETCLOSE >  {    symbolTable.leaveScope();  }}void Definition() :{}{  (    VarDef(Kind.fieldKind)  | FuncDef()  )*}void VarDef(Kind kind) :{  Type type;  Token token;  Symbol symbol;}{  type = Type() (< ARRAY >)? token = < IDENT >  {    int spix = nameList.insert(token.image);    symbol = new Symbol(spix, kind, type);    symbolTable.insert(symbol);    classfile.addVarConstant(symbol);  }  (    Init(symbol)  )?  < END >}void Init(Symbol varSy) :{  varSy.init = true;}{  //TODO set symbol.val 
  < ASSIGN > Expr() | CallStat()}Type Type() :{}{  (    < VOID >    {      return Type.voidType;    }  | < INT >    {      return Type.intType;    }  | < BOOLEAN >    {      return Type.boolType;    }  )}void FuncDef() :{  Type type;  Token identToken;  MethodSymbol symbol;}{  < FUNCTION > (< COROUTINE >)? type = Type() identToken = < IDENT >  {    int spix = nameList.insert(identToken.image);    symbol = new MethodSymbol(spix, Kind.funcKind, type);    symbolTable.insert(symbol);    symbolTable.enterScope(identToken.image);  }  < ROUNDBRACKETOPEN > FormParamList(symbol) < ROUNDBRACKETCLOSE >  {    MethodRefConstant method = (MethodRefConstant)classfile.addMethodConstant(symbol, symbolTable.getCurrentScope());
    codeGen.setCurrCode(method.getMethodCode());  }  Block()  {    symbolTable.leaveScope();  }}void FormParamList(MethodSymbol method) :{}{
  (
    FormParam(method)
    (
      < SEPERATOR > FormParam(method)    )*  )?}

void FormParam(MethodSymbol method) :
{  Type type;
  Token token;
  Symbol symbol;}
{  (< BYREF >)? type = Type() token = < IDENT >
  {
    int spix = nameList.insert(token.image);
    symbol = new Symbol(spix, Kind.parKind, type);
    symbolTable.insert(symbol);
    method.addParam(symbol);
  }
}void Block() :{}{  < CURLYBRACKETOPEN >  (	Stat()  )*  < CURLYBRACKETCLOSE >}void Stat() :{}{
  VarDef(Kind.varKind)| AssignStat()
| CallStat()| IfStat()| WhileStat()| ReturnStat()| < END >}void AssignStat() :{  Token token;  Symbol symbol;}{  token = < IDENT >  {    symbol = symbolTable.lookup(token.image);  }  < ASSIGN > Expr()}void CallStat() :{}{  Call() < END >}void Call() :{}{
  < CALL >  < IDENT > < ROUNDBRACKETOPEN >  (    ActParList()  )?  < ROUNDBRACKETCLOSE >}void ActParList() :{}{  Expr()  (    < SEPERATOR > Expr()  )*}void IfStat() :{}{  < IF > < ROUNDBRACKETOPEN > Expr() < ROUNDBRACKETCLOSE >  {    symbolTable.enterScope("if");  }  Block()  {    symbolTable.leaveScope();  }  (    < ELSE >    {      symbolTable.enterScope("else");    }    Block()    {      symbolTable.leaveScope();    }  )?}void WhileStat() :{}{  < WHILE > < ROUNDBRACKETOPEN > Expr() < ROUNDBRACKETCLOSE >  {    symbolTable.enterScope("while");  }  Block()  {    symbolTable.leaveScope();  }}void ReturnStat() :{}{  < RETURN >  (    Expr()  )?  < END >}void Expr() :{}{  OrExpr()}void OrExpr() :{}{  AndExpr()  (    < OR > AndExpr()  )*}void AndExpr() :{}{  RelExpr()  (    < AND > RelExpr()  )*}void RelExpr() :{}{  SimpleExpr()  (    (      ComparisonOperators()    )    SimpleExpr()  )?}void SimpleExpr() :{}{  (    PlusMinus()  )?  Term()  (    PlusMinus() Term()  )*}void PlusMinus() :{}{  < PLUS >| < MINUS >}void Term() :{}{  NotFact()  (    MuliplyDivide() NotFact()  )*}void NotFact() :{}{  (< NOT >)? Fact()}void Fact() :{}{  (    < NUMBER >  | < FALSE >  | < TRUE >  | < IDENT >  | CallStat()  |    (      < ROUNDBRACKETOPEN > Expr() < ROUNDBRACKETCLOSE >    )  | < NEW > Type() < RECTBRACKETOPEN > < NUMBER > < RECTBRACKETCLOSE >  )}void MuliplyDivide() :{}{  < MULTIPLY >| < DIVIDE >}void ComparisonOperators() :{}{  (    < EQ >  | < NOTEQ >  | < SMALLER >  | < SMALLEREQ >  | < GREATER >  | < GREATEREQ >  )}