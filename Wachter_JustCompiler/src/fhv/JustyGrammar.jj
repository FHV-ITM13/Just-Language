/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(EG1)package fhv;import java.io.*;
import fhv.semantic.context.*;
import fhv.semantic.*;public class EG1{  public static void main(String args [])  {     try	{
	  int s1 = Namelist.nameList.insert("println");
	  Symbol printlnSymbol = new Symbol(s1, Symbol.Kind.systemFuncKind);
	  int s2 = Namelist.nameList.insert("start");
	  Symbol startSymbol = new Symbol(s2, Symbol.Kind.systemFuncKind);
	  
	  SymbolTable.symbolTable.insert(printlnSymbol);
	  SymbolTable.symbolTable.insert(startSymbol);
	      EG1 parser = new EG1(new FileInputStream("Just/test.just"));      parser.file();
      System.out.println("OK.");    }    catch (ParseException e)    {      System.out.println("NOK.");      System.out.println(e.getMessage());      EG1.ReInit(System.in);    }
    catch (Error e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
    }
    catch (Exception e)
    {
      System.out.println("Other oops.");
      System.out.println(e.getMessage());

      e.printStackTrace();
    }  }}PARSER_END(EG1)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >}TOKEN : /*  */{  < PROGRAM : "program" >| < VAR : "var" >| < CALL : "call" >| < IMPORT : "import" >| < RETURN : "return" >| < BYREF : "byref" >| < COROUTINE : "coroutine" >| < SYNCHRONIZED : "synchronized" >| < NEW : "new" >| < POINT : "." >| < TRUE : "true" >| < FALSE : "false" >| < END : ";" >| < SEPERATOR : "," >}TOKEN :{  < OR : "||" >| < AND : "&&" >}TOKEN : /* BRACES */{  < OPEN_CURLY : "{" >| < CLOSE_CURLY : "}" >| < OPEN : "(" >| < CLOSE : ")" >| < OPEN_RECT : "[" >| < CLOSE_RECT : "]" >}TOKEN :{  < EQUAL : "==" >| < NOT_EQUAL : "!=" >| < SMALLER : "<" >| < GREATOR : ">" >| < SMALLER_EQUAL : "<=" >| < GREATOR_EQUAL : ">=" >| < NOT : "|" >}TOKEN : /* TYPES */{  < INT : "int" >| < BOOL : "boolean" >| < VOID : "void" >| < ARRAY : (< OPEN_RECT > < CLOSE_RECT >) >}TOKEN : /* IF */{  < IF : "if" >| < ELSE : "else" >}TOKEN : /* WHILE */{  < DO : "do" >| < WHILE : "while" >}TOKEN : /* ASSIGN OPERATORS */{  < ASSIGN : "=" >}TOKEN : /* Identifier */{  < IDENTIFIER :    (      < LOWER_LETTER >    | < UPPER_LETTER >    )    (      < LOWER_LETTER >    | < UPPER_LETTER >    | < NUMBER >    )*     >| < #LOWER_LETTER : [ "a"-"z" ] >| < #UPPER_LETTER : [ "A"-"Z" ] >}TOKEN : /* Number */{  < NUMBER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}void file() :{}{  (< IMPORT > < IDENTIFIER > < END >)* program()}void program() :{}{  < PROGRAM >
  {
    SymbolTable.symbolTable.enterScope();  }
  < IDENTIFIER > < OPEN_CURLY > programDef()
  {
    SymbolTable.symbolTable.leaveScope();  }
  < CLOSE_CURLY >}void programDef() :{}{  (    varDef()  | funcDef()  )*}void type() :{}{  (    < VOID >  | < INT >  | < BOOL >  )}void funcDef() :{
  Token token;
  Symbol symbol;
  Integer spix;
}{  (< COROUTINE >)?
  type()
  token=< IDENTIFIER >  {
    spix = Namelist.nameList.insert(token.image);
    symbol = new Symbol(spix, Symbol.Kind.funcKind);
    SymbolTable.symbolTable.insert(symbol);
    SymbolTable.symbolTable.enterScope();  }
  < OPEN >
  funcParamList()
  < CLOSE >
  block()
  {
    SymbolTable.symbolTable.leaveScope();  }}void funcParamList() :{
}{  (    (< BYREF >    )? funcParam()    (      < SEPERATOR >       (      < BYREF >      )? funcParam()    )*  )?}void funcParam() :{
  Token token;
  Integer spix;
  Symbol symbol;
}{  type()
  token=< IDENTIFIER >
  {
    spix = Namelist.nameList.insert(token.image);
    symbol = new Symbol(spix, Symbol.Kind.parKind);
    SymbolTable.symbolTable.insert(symbol);
  }}void varDef() :{
  Token token;
  Integer spix;
  Symbol symbol;
}{  < VAR >   type()   (< ARRAY >  )?   token = < IDENTIFIER >
  {
    spix = Namelist.nameList.insert(token.image);
    symbol = new Symbol(spix, Symbol.Kind.varKind);
    SymbolTable.symbolTable.insert(symbol);   }  (    < ASSIGN >     expr()  )?  < END >}void block() :{}{  < OPEN_CURLY >  (    varDef()  | stat()  )*  < CLOSE_CURLY >}void stat() :{}{  block()| assignStat()| ifStat()| callStat()| whileStat()| synchronizedStat()| returnStat()}

void assignStat() :{}{  var() < ASSIGN > expr() < END >}void callStat() :{}{  < CALL > call() < END >}void ifStat() :{}{  < IF > < OPEN > expr() < CLOSE > stat()  (    < ELSE > stat()  )?}void whileStat() :{}{  < WHILE >
  < OPEN >
  expr()
  < CLOSE >
  {
    SymbolTable.symbolTable.enterScope();
  }
  stat()
  {
    SymbolTable.symbolTable.leaveScope();
  }}void synchronizedStat() :{}{  < SYNCHRONIZED >   < OPEN >   expr()   < CLOSE > 
  {
    SymbolTable.symbolTable.enterScope();
  }  stat()
  {
    SymbolTable.symbolTable.leaveScope();
  }}void returnStat() :{}{  < RETURN >  (    expr()  )?  < END >}void call() :{}{  var() < OPEN > actParamList() < CLOSE >}void expr() :{}{  orExpr()}void orExpr() :{}{  andExpr()  (    < OR > andExpr()  )*}void andExpr() :{}{  relExpr()  (    < AND > relExpr()  )*}void relExpr() :{}{  simpleExpr()  (    comparisonOperator()     simpleExpr()  )*}void comparisonOperator() :{}{  < EQUAL >| < NOT_EQUAL >| < SMALLER >| < GREATOR >| < SMALLER_EQUAL >| < GREATOR_EQUAL >}void simpleExpr() :{}{  (    < PLUS >  | < MINUS >  )?  term()  (    (      < PLUS >    | < MINUS >    )    term()  )*}void term() :{}{  notFactor()  (    (      < MULTIPLY >    | < DIVIDE >    )    notFactor()  )*}void notFactor() :{}{  (  < NOT >
  )?
  factor()}void factor() :{}{  < NUMBER >| var()| callStat()|  (    < OPEN > expr() < CLOSE >  )|  (    < NEW >     type()    (      < OPEN_RECT >      (        var()      | < NUMBER >      )      < CLOSE_RECT >    )?  )| < TRUE >| < FALSE >}void var() :{
  Token token;
  Symbol symbol;
}{  token = < IDENTIFIER >
  {
    symbol = SymbolTable.symbolTable.lookup(token.image);  }  (    // ARRAY
    (      < OPEN_RECT >      (        var()      | < NUMBER >      )      < CLOSE_RECT >    )    // sub var
  |    (      subVar()    )  )*}

void subVar():{}{
  < POINT > 
  < IDENTIFIER >}void actParamList() :{}{  (    expr()    (      < SEPERATOR > expr()    )*  )?}

